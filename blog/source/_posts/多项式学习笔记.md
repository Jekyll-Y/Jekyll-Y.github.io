---
title: 多项式学习笔记
date: 2022-09-26 21:14:13
tags:
- 多项式
- 快速傅里叶变换(FFT)
- 快速数论变换(NTT)
- 任意模数NTT
- 多项式乘法逆
- 多项式对数函数(多项式求ln)
- 多项式指数函数(多项式exp)
- 多项式开根
- 多项式幂函数
- 分治FFT/NTT
- 下降幂多项式乘法
- 多项式除法
categories : 
- 学习笔记
toc: true
cover: https://s2.loli.net/2022/09/27/OFTXHsAdoIq6pRb.png
thumbnail: https://s2.loli.net/2022/09/27/OFTXHsAdoIq6pRb.png

---

超全的多项式全家桶(❁´◡`❁)

感谢Meteorshower-Y的大力支持和指导， 这是大佬的[blog](https://meteorshower-y.github.io/)！！ヾ(≧▽≦*)o

<!--more-->

# 多项式学习笔记

## 快速傅里叶变换(FFT)

**快速傅里叶变换(FFT)**，主要用于加速多项式乘法，对于两个多项式$A$和$B$， FFT可以将朴素的$O(n^2)$优化为$O(n \log n)$。

### 单位元

先看一下单位元的几个性质，在接下来的算法中有很大的用途。

1. $\omega_n ^ k = e ^{\frac{2\pi i k}{n}}$
2. $\omega_{dn} ^ {dk} = \omega_n^k$
3. $\omega_n^k = a + bi, \omega_n^{-k} = a - bi$
4. $\omega _n ^{k + \frac{n}{2}} = - \omega_n^k$ 

以上变换均可由欧拉公式$e^{i \theta} = \cos \theta + i\sin \theta$推得。

### 离散傅里叶变换(DFT)

**离散傅里叶变换(DFT)** 主要是利用分治思想，根据一个$n$次的多项式可以由$n + 1$个点唯一确定，

首先将多项式

$$
A(x) = \sum_{i=0} ^n a_i x^i
$$

其系数进行奇偶性分类，得到，

$$
A_0(x)= a_0+a_2 x^1 +a_4 x^2 + \cdots \\
A_1(x)= a_1+a_3 x^1 +a_5 x^2 + \cdots \\
$$

所以我们可以表示为 ：

$$
A(x) = A_0 (x^2) +x \cdot A_1(x^2)
$$

将 $\omega_n^k$ 与 $\omega_n^{k+ \frac{n}{2}}$代入得：

$$
\left\{
\begin{aligned}
&A(\omega_n^k) &= &A_0(\omega_n^{2k})+\omega_n^k A_1(\omega_n^{2k}) \\
&A(\omega_n^{k+ \frac{n}{2}}) &= &A_0(\omega_n^{2k})-\omega_n^k A_1(\omega_n^{2k}) \\
\end{aligned}
\right.
$$



同时我们可以发现两个式子只有常数不一样，递归计算即可。

时间复杂度$O(n \log n)$ 。

在这里我们将系数变成了点值。

### 离散傅里叶逆变换(IDFT)

**离散傅里叶逆变换(IDFT)**，可以将点值快速转化为系数，从而得出结果多项式。

需要用到单位根反演：
$$
\frac{1}{n} \sum_{i=0}^{n-1} \omega_n^{x \ast i} = [x \bmod n =0] 
$$
证明 ：

由于 $\omega_n ^ {x \ast i} = \omega_n^ {x \ast (i-1)} \ast \omega_n^x$ 

所以$\omega _n ^{x\ast i}$ 为等比数列，
$$
\therefore 
\frac{1}{n} \sum_{i=0}^{n-1} \omega_n^{x \ast i}=
\left\{
\begin{aligned}
&\frac{1}{n} \sum_{i=0}^{n-1} 1^i = \frac{n}{n} = 1  & x \bmod n=0\\
&\frac{1}{n} \cdot  \frac{1- \omega _n ^ {n \ast x}}{1-\omega _n ^ x} = \frac{1}{n} \cdot \frac{1-1^x}{1-\omega_n^x} =0 & x\bmod n \ne 0
\end{aligned}
\right.
$$
证明
$$
设  c= a\ast b  \\
\begin{aligned}
c_i
&= \sum_{j=0}^i a_j \cdot b_{i-j} \\
&=\sum_{p=0}\sum_{q=0} a_p \cdot b_q [(p+q) \bmod n=0] \\
nc_i 
&= \sum_{p=0}\sum_{q=0} a_p \cdot b_q \sum_{j=0} \omega_n^{(p+q-i)j}\\
&= \sum_{j=0}\omega_n^{(-i)j} \bigg( \sum_{p=0} \omega_n^{pj} a_p\bigg) \bigg( \sum_{q=0} \omega_n^{qj} b_q\bigg) 
\end{aligned} \\
设 f_a(j) = \sum_{i=0} \omega_n^{ij} a_i , f_a^{-1}(j) =\sum_{i=0} \omega_n^{(-i)j} a_i \\
\begin{aligned}
nc_i 
&= \sum_{j=0} \omega_n^{(-i)j}f_a(j)f_b(j) \\
&= \sum_{j=0} \omega_n^{(-i)j}f_c(j) \\
&= f_{f_c}^{-1} (i)
\end{aligned}
$$
因为 $f_a$ 就是 $a$ 在 DFT 后的结果，所以$f_a^{-1}$就是 对应的IDFT，最后**除以对应长度**$n$，即为所求。

~~~c++
#include <bits/stdc++.h>

using namespace std;

const int N = 4e6 + 10;
const double pi = acos(-1.0);

int n, m;

struct Complex
{
    double a, b;
    Complex(double x = 0, double y = 0) : a(x), b(y) {}
    friend Complex operator + (Complex x, Complex y) {return Complex(x.a + y.a, x.b + y.b);}
    friend Complex operator - (Complex x, Complex y) {return Complex(x.a - y.a, x.b - y.b);}
    friend Complex operator * (Complex x, Complex y) {return Complex(x.a * y.a - x.b * y.b, x.b * y.a + y.b * x.a);}
};

int recover[N];

Complex F[N], G[N], H[N];

void FFT(Complex *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        Complex x(cos(pi / k), type * sin(pi / k));
        for(int i = 0; i < len; i += (k << 1))
        {
            Complex w(1, 0);
            for(int j = 0; j < k; j++)
            {
                Complex y = a[i + j];
                Complex z = w * a[i + j + k];
                a[i + j] = y + z;
                a[i + j + k] = y - z;
                w = w * x;
            }
        }
    }
    if(type == -1)
        for(int i = 0; i < len; i++)
            a[i].a /= len;
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 0; i <= n; i++)
        scanf("%lf", &F[i].a);
    for(int i = 0; i <= m; i++)
        scanf("%lf", &G[i].a);
    int len = 1, cnt = 0;
    while(len <= (n + m))len <<= 1, cnt++;
    for(int i = 0; i <= len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    FFT(F, len, 1), FFT(G, len, 1);
    for(int i = 0; i <= len; i++)
        H[i] = F[i] * G[i];
    FFT(H, len, -1);
    for(int i = 0; i <= n + m; i++)
        printf("%d ", (int)(H[i].a + 0.5));
    return 0;
}
~~~



## 快速数论变换(NTT)

**快速数论变换**(NTT)相比于FFT虽然时间复杂度均为$O(n\log n)$，但是FFT的精度却难以保证，并且常数很大， 所以有时NTT才是更好的选择。

### 原根

**原根**定义为：设$m$为正整数，$a$是整数，若$a \bmod m$的阶等于$\varphi (m)$，则称$a$为$\bmod  m$的一个原根。

原根有一个很重要的性质可以支持像FFT中单位根一样的运算，即：若$P$为素数， 假设一个数$g$是$P$的原根， 那么$g^i \bmod P$的结果两两不同。

可以得到：
$$
\omega_n \equiv g^{\frac{p - 1}{n}} \mod p
$$
然后我们就可以将FFT中的$\omega _n$替换为$g^{\frac{p - 1}{n}}$

但是注意的是NTT对模数有要求，其模数必须要满足原根的定义，否则是不能使用NTT的，比如$998244353$就为NTT模数， 其原根为$3$。

~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 4e6 + 10;
const int mod = 998244353;
const int g = 3;
const int gi = 332748118;

int n, m;

int F[N], G[N], H[N];

int qpow(int a, int b)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1)t = t * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return t;
}

int recover[N];

void NTT(int *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi, (mod - 1) / (k << 1));
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j];
                int z = w * a[i + j + k] % mod;
                a[i + j] = (y + z) % mod;
                a[i + j + k] = (y - z + mod) % mod;
                w = (w * x) % mod;
            }
        }
    }
    if(type == -1)
    {
        int inv = qpow(len, mod - 2);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * inv % mod;
    }
}

signed main()
{
    scanf("%lld%lld", &n, &m);
    for(int i = 0; i <= n; i++)
        scanf("%lld", &F[i]);
    for(int i = 0; i <= m; i++)
        scanf("%lld", &G[i]);
    int len = 1, cnt = 0;
    while(len <= (n + m))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    NTT(F, len, 1), NTT(G, len, 1);
    for(int i = 0; i < len; i++)
        H[i] = (F[i] * G[i]) % mod;
    NTT(H, len, -1);
    for(int i = 0; i <= n + m; i++)
        printf("%lld ", H[i]);
    return 0;
}
~~~

## 任意模数快速数论变换

普通的NTT对模数是有要求的其必须满足原根的相关定义，模数必须可以写成$a \cdot 2 ^ k + 1$的形式。

比如：
$$
469762049 = 7 \times 2 ^ {26} + 1 (g = 3) \\
998244353 = 119 \times 2 ^{23} + 1(g = 3) \\
1004535809 = 479 \times 2 ^ {21} + 1(g = 3)
$$
如果题目中模数为$1e9 + 7$，那么NTT就会受到限制，然后就可以使用**任意模数NTT**，（也可以称为三模数NTT），

计算时可以先找三个大质数， 分别计算结果，然后用中国剩余定理CRT合并即可。

首先记三次NTT的结果为：
$$
ans \equiv a_1 \mod p_1 \\
ans \equiv a_2 \mod p_2 \\
ans \equiv a_3 \mod p_3
$$
先合并前两个得到:
$$
ans \equiv a_4 \mod p_1 p_2
$$
将其转化为等式为：
$$
ans = k p_1 p_2 + a_4
$$
接着求$k$：
$$
k = (a_3 - a_4)p_1^{-1} p_2 ^ {-1} \mod p_3
$$
所以：
$$
ans \equiv kp_1 p_2 + a_4 \mod p_1p_2p_3
$$
~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int __int128

const int N = 4e5 + 10;
const int g = 3;

int read()
{
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9'){x = x*10 + ch-'0'; ch = getchar();}
    return x * f;
}

void write(int x)
{
    char ch[100], len = 0;
    if(x == 0)ch[++len] = '0';
    while(x)ch[++len] = x%10 + '0', x /= 10;
    while(len)putchar(ch[len--]);
    printf(" ");
}

int p[3] = {469762049, 998244353, 1004535809};

int qpow(int a, int b, int i)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1) t = t * a % p[i];
        a = a * a % p[i]; b >>= 1;
    }
    return t % p[i];
}

int inv(int x, int i)
{
    return qpow(x, p[i] - 2, i);
}

int gi[3];

void init()
{
    for(int i = 0; i < 3; i++)
        gi[i] = inv(g, i);
}

int F[N], G[N], H[N];

int recover[N];

void NTT(int *a, int len, int type, int f)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi[f], (p[f] - 1) / (k << 1), f);
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j] % p[f];
                int z = w * a[i + j + k] % p[f];
                a[i + j] = (y + z) % p[f];
                a[i + j + k] = (y - z + p[f]) % p[f];
                w = w * x % p[f];
            }
        }
    }
    if(type == -1)
    {
        int iv = inv(len, f);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * iv % p[f];
    }
}

int A[N], B[N], C[3][N];

void CRT(int len)
{
    int M = p[0] * p[1];
    for(int i = 0; i <= len; i++)
    {
        H[i] = (p[1] * C[0][i] % M * inv(p[1], 0) % M
        + p[0] * C[1][i] % M * inv(p[0], 1) % M) % M;
    }
}

int n, m, mod;

void merge(int len)
{
    for(int i = 0; i <= len; i++)
    {
        int k = ((C[2][i] - H[i]) % p[2] + p[2]) % p[2] * inv(p[0] * p[1], 2) % p[2];
        H[i] = ((k * p[0] * p[1] % mod + H[i] % mod) % mod + mod) % mod;
    }
}

void prework()
{
    memcpy(A, F, sizeof(F));
    memcpy(B, G, sizeof(G));
}

void update(int x, int len)
{
    for(int i = 0; i < len; i++)
        C[x][i] = A[i] * B[i] % p[x];
}

signed main()
{
    init();
    n = read(), m = read(), mod = read();
    for(int i = 0; i <= n; i++)
        F[i] = read();
    for(int i = 0; i <= m; i++)
        G[i] = read();
    int len = 1, cnt = 0;
    while(len <= (n + m))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    for(int i = 0; i < 3; i++)
    {
        prework();
        NTT(A, len, 1, i), NTT(B, len, 1, i);
        update(i, len);
        NTT(C[i], len, -1, i);
    }
    CRT(n + m); merge(n + m);
    for(int i = 0; i <= (n + m); i++)
        write(H[i]);
    return 0;
}
~~~



## 多项式乘法逆

定义多项式$F ^ {-1}$为多项式$F$的乘法逆元，满足
$$
F \ast F ^ {-1} \equiv 1 \mod x ^n
$$
假设我们已经得知$F \ast G' \equiv 1 \bmod x ^ {\frac{n}{2}}$， 来求$F \ast G \equiv 1 \bmod x ^ n$
$$
\because F \ast G' \equiv 1 \mod x ^ {\frac{n}{2}} , F \ast G \equiv 1 \mod x ^ n \\
\therefore F \ast G  \equiv 1 \mod x ^ {\frac{n}{2}} \\
\therefore G' - G \equiv 0 \mod x ^ {\frac{n}{2}} \\
\therefore (G' - G) ^ 2 \equiv 0 \mod x ^ n \\
G'^2 - 2 G G' + G^2 \equiv 0 \mod x ^ n \\
$$
接下来两边同时$\ast F$， 
$$
F G'^2 - 2 G' + G \equiv 0 \bmod x ^ n \\
\therefore G \equiv 2 G' - FG'^2 \bmod x ^ n
$$
然后直接递归即可， 使用NTT， 时间复杂度$O(n \log n)$。

~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 4e5 + 10;
const int mod = 998244353;
const int g = 3;
const int gi = 332748118;

int qpow(int a, int b)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1)t = t * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return t;
}

int inv(int x)
{
    return qpow(x, mod - 2);
}

int F[N], G[N];

int recover[N];

void NTT(int *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi, (mod - 1) / (k << 1));
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j] % mod;
                int z = w * a[i + j + k] % mod;
                a[i + j] = (y + z) % mod;
                a[i + j + k] = (y - z + mod) % mod;
                w = w * x % mod;
            }
        }
    }
    if(type == -1)
    {
        int iv = inv(len);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * iv % mod;
    }
}

int c[N];

void mul(int n, int *a, int *b)
{
    if(n == 1)
    {
        b[0] = inv(a[0]);
        return;
    }
    mul((n + 1) >> 1, a, b);
    int len = 1, cnt = 0;
    while(len <= (n << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    for(int i = 0; i < n; i++)
        c[i] = a[i];
    for(int i = n; i < len; i++)
        c[i] = 0;
    NTT(c, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod;
    NTT(b, len, -1);
    for(int i = n; i < len; i++)b[i] = 0;
}

signed main()
{
    int n; scanf("%lld", &n);
    for(int i = 0; i < n; i++)
        scanf("%lld", &F[i]);
    mul(n, F, G);
    for(int i = 0; i < n; i++)
        printf("%lld ", (G[i] % mod + mod) % mod);
    return 0;
}
~~~



## 多项式对数函数(多项式求ln)

定义多项式对数函数为
$$
G = \ln (F) \bmod x ^ n
$$
假设我们有多项式$F(x)$和$G(x)$， 记$G = \ln F \bmod x ^ n$，


$$
G \equiv \ln F \mod x ^ n \\
G'\equiv (\ln F)’ \mod x ^ n \\ 
G' \equiv (\ln' F )\ast F ' \mod x ^n \\
G' \equiv \frac{F'}{F} \mod x^n
$$
多项式求逆，再积回去就好啦。

需要用到求导：$x ^ {a'} = ax ^ {a - 1}$， 积分：$\int x^a \mathrm{d}x = \frac{1}{a + 1}x ^ {a + 1}$。**需要保证**$F_0 = 1$。

~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 4e5 + 10;
const int mod = 998244353;
const int g = 3;
const int gi = 332748118;

int recover[N];

int qpow(int a, int b)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1)t = t * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return t;
}

int inv(int x)
{
    return qpow(x, mod - 2);
}

void NTT(int *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi, (mod - 1) / (k << 1));
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j] % mod;
                int z = w * a[i + j + k] % mod;
                a[i + j] = (y + z) % mod;
                a[i + j + k] = (y - z + mod) % mod;
                w = w * x % mod;
            }
        }
    }
    if(type == -1)
    {
        int iv = inv(len);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * iv % mod;
    }
}

void inverse(int *a, int *b, int n)
{
    if(n == 1)
    {
        b[0] = inv(a[0]);
        return;
    }
    inverse(a, b, (n + 1) >> 1);
    int len = 1, cnt = 0;
    while(len <= (n << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    int c[N]; memset(c, 0, sizeof(c));
    for(int i = 0; i < n; i++)
        c[i] = a[i];
    for(int i = n; i < len; i++)
        c[i] = 0;
    NTT(c, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod;
    NTT(b, len, -1);
    for(int i = n; i < len; i++)b[i] = 0;
}

void mul(int *a, int *b, int *c, int n, int m)
{
    int len = 1, cnt = 0;
    while(len <= (n + m))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    NTT(a, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        c[i] = a[i] * b[i] % mod;
    NTT(c, len, -1);
}

void add(int *a, int *b, int *c, int n, int m, int k)
{
    for(int i = 0; i <= max(n, m); i++)
        c[i] = (a[i] + k * b[i] + mod) % mod;
}

void diff(int *a, int *b, int n)
{
    for(int i = 1; i < n; i++)
        b[i - 1] = i * a[i] % mod;
    b[n - 1] = 0;
}

void integ(int *a, int *b, int n)
{
    for(int i = 1; i < n; i++)
        b[i] = a[i - 1] * inv(i) % mod;
    b[0] = 0;
}

int F[N], G[N], H[N];

void polyln(int *a, int *b, int n)
{
    int f[N], h[N];
    memset(f, 0, sizeof(f));
    memset(h, 0, sizeof(h));
    diff(a, f, n);
    inverse(a, h, n);
    mul(f, h, H, n, n);
    integ(H, b, n);
}

int n;

signed main()
{
    scanf("%lld", &n);
    for(int i = 0; i < n; i++)
        scanf("%lld", &F[i]);
    polyln(F, G, n);
    for(int i = 0; i < n; i++)
        printf("%lld ", G[i]);
    return 0;
}
~~~



## 多项式指数函数(多项式exp)

定义多项式指数函数为
$$
G(x) = e ^ {F(x)} \bmod x ^ n
$$

### 牛顿迭代

**牛顿迭代**用于求函数零点，通过不断地切线逼近所求值，但最终也只是近似值，迭代的次数越多，精确度越高，误差越小。

假如我们要对一个非常大的数$a$开方，手算，利用牛顿法来解决这个问题，其实本质上是求得$f(x) = x ^2 - a$精确到整数得零点，假设我们已经求得了一个近似值$x_0$，那么我们只需要过$(x_0, f(x_0))$这个点， 作这个函数图像的切线，取切线与$x$轴的交点作为新的$x_0$。

假设我们要求一个函数$f(x)$的零点， 初始近似值是$x_0$，则切线方程为
$$
y = f'(x_0)(x - x_0) + f(x_0)
$$
令$y = 0$，得到$x = x_0 - \frac{f(x_0)}{f'(x_0)}$。

假设我们现在要求$F(G(x)) \equiv 0$，然后利用上面的式子每一次令
$$
G(x) = G_0(x) - \frac{F(G_0(x))}{F'(G_0(x))}
$$
然后就可以很快的逼近真实值。



接下来推一下多项式exp
$$
B(x) \equiv e ^ {A(x)} \bmod x ^ n \\
\ln B(x) - A(x) \equiv 0 \bmod x^ n
$$
现在问题变为了使得$F(G(x)) = \ln G(x) - A(x) \equiv  0$。

然后求导，
$$
F'(G_0(x)) = \frac{1}{G_0(x)}
$$
然后接着带入上面牛顿迭代的式子，
$$
G(x) = {G_0(x)(1 - \ln G_0(x) + A(x))}
$$
每次迭代，使用多项式求$\ln$，然后再做一遍多项式乘法，然后就可以得到答案，时间复杂度$O(n \log n)$。

**需要保证**$F_0 = 0$。

~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 4e5 + 10;
const int mod = 998244353;
const int g = 3;
const int gi = 332748118;

int recover[N];

int qpow(int a, int b)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1)t = t * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return t;
}

int inv(int x)
{
    return qpow(x, mod - 2);
}

void NTT(int *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi, (mod - 1) / (k << 1));
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j] % mod;
                int z = w * a[i + j + k] % mod;
                a[i + j] = (y + z) % mod;
                a[i + j + k] = (y - z + mod) % mod;
                w = w * x % mod;
            }
        }
    }
    if(type == -1)
    {
        int iv = inv(len);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * iv % mod;
    }
}

void inverse(int *a, int *b, int n)
{
    if(n == 1)
    {
        b[0] = inv(a[0]);
        return;
    }
    inverse(a, b, (n + 1) >> 1);
    int len = 1, cnt = 0;
    while(len <= (n << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    int c[N]; memset(c, 0, sizeof(c));
    for(int i = 0; i < n; i++)
        c[i] = a[i];
    for(int i = n; i < len; i++)
        c[i] = 0;
    NTT(c, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod;
    NTT(b, len, -1);
    for(int i = n; i < len; i++)b[i] = 0;
}

void mul(int *a, int *b, int *c, int n, int m)
{
    int len = 1, cnt = 0;
    while(len <= (n + m))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    NTT(a, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        c[i] = a[i] * b[i] % mod;
    NTT(c, len, -1);
}

void add(int *a, int *b, int *c, int n, int m, int k)
{
    for(int i = 0; i <= max(n, m); i++)
        c[i] = (a[i] + k * b[i] + mod) % mod;
}

void diff(int *a, int *b, int n)
{
    for(int i = 1; i < n; i++)
        b[i - 1] = i * a[i] % mod;
    b[n - 1] = 0;
}

void integ(int *a, int *b, int n)
{
    for(int i = 1; i < n; i++)
        b[i] = a[i - 1] * inv(i) % mod;
    b[0] = 0;
}

int F[N], G[N], H[N];

void polyln(int *a, int *b, int n)
{
    int f[N], h[N];
    memset(f, 0, sizeof(f));
    memset(h, 0, sizeof(h));
    diff(a, f, n);
    inverse(a, h, n);
    mul(f, h, H, n, n);
    integ(H, b, n);
}

void polyexp(int *a, int *b, int n)
{
    if(n == 1)
    {
        b[0] = 1;
        return;
    }
    polyexp(a, b, (n + 1) >> 1);
    int len = 1, cnt = 0;
    while(len <= (n << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    int c[N];
    memset(c, 0, sizeof(c));
    c[0] = 1;
    int f[N]; memset(f, 0, sizeof(f));
    polyln(b, f, n);
    add(c, a, c, n, n, 1);
    add(c, f, c, n, n, -1);
    mul(c, b, c, n, n);
    for(int i = 0; i < n; i++)
        b[i] = c[i];
    for(int i = n; i < len; i++)
        b[i] = 0;
}

int n;

signed main()
{
    scanf("%lld", &n);
    for(int i = 0; i < n; i++)
        scanf("%lld", &F[i]);
    polyexp(F, G, n);
    for(int i = 0; i < n; i++)
        printf("%lld ", G[i]);
    return 0;
}
~~~



## 多项式开根

多项式开根用来解决
$$
G^2(x) \equiv F(x) \bmod x^n
$$
假设我们有$G'^2(x) \equiv F(x) \bmod x ^ {\frac{n}{2}}, H(G(x)) = G^2(x) - F$，求$G^2(x) \equiv F(x) \bmod  x ^ n$，
$$
G'^2 (x) \equiv F(x) \mod  x ^ {\frac{n}{2}} , G^2(x) \equiv F(x) \mod x ^ {\frac{n}{2}} \\
G^2(x) - F \equiv 0 \mod x ^ {\frac{n}{2}} \\
H(G) \equiv 0 \mod x ^ {\frac{n}{2}} \\
G \equiv G' - \frac{H(G')}{H'(G')} \mod x ^ n \\
G \equiv \frac{G'^2 + F} {2G'} \mod x ^ n
$$

需要保证$F_0 = 1$。

~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 4e5 + 10;
const int mod = 998244353;
const int g = 3;
const int gi = 332748118;

int recover[N];

int qpow(int a, int b)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1)t = t * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return t;
}

int inv(int x)
{
    return qpow(x, mod - 2);
}

int inv2 = inv(2);

void NTT(int *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi, (mod - 1) / (k << 1));
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j] % mod;
                int z = w * a[i + j + k] % mod;
                a[i + j] = (y + z) % mod;
                a[i + j + k] = (y - z + mod) % mod;
                w = w * x % mod;
            }
        }
    }
    if(type == -1)
    {
        int iv = inv(len);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * iv % mod;
    }
}

void inverse(int *a, int *b, int n)
{
    if(n == 1)
    {
        b[0] = inv(a[0]);
        return;
    }
    inverse(a, b, (n + 1) >> 1);
    int len = 1, cnt = 0;
    while(len <= (n << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    int c[N]; memset(c, 0, sizeof(c));
    for(int i = 0; i < n; i++)
        c[i] = a[i];
    for(int i = n; i < len; i++)
        c[i] = 0;
    NTT(c, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        b[i] = (2 - b[i] * c[i] % mod + mod) % mod * b[i] % mod;
    NTT(b, len, -1);
    for(int i = n; i < len; i++)b[i] = 0;
}

void mul(int *a, int *b, int *c, int n, int m)
{
    int len = 1, cnt = 0;
    while(len <= (n + m))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    NTT(a, len, 1), NTT(b, len, 1);
    for(int i = 0; i < len; i++)
        c[i] = a[i] * b[i] % mod;
    NTT(c, len, -1);
}

void add(int *a, int *b, int *c, int n, int m, int k)
{
    for(int i = 0; i <= max(n, m); i++)
        c[i] = (a[i] + k * b[i] + mod) % mod;
}
int F[N], G[N], H[N];

void polysqrt(int *a, int *b, int n)
{
    if(n == 1)
    {
        b[0] = 1;
        return;
    }
    polysqrt(a, b, (n + 1) >> 1);
    int len = 1, cnt = 0;
    while(len <= (n << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    int c[N]; memset(c, 0, sizeof(c));
    int f[N]; memset(f, 0, sizeof(f));
    inverse(b, f, n);
    for(int i = 0; i < n; i++)
        c[i] = a[i];
    NTT(f, len, 1), NTT(b, len, 1), NTT(c, len, 1);
    for(int i = 0; i < len; i++)
        b[i] = (b[i] + c[i] * f[i] % mod) % mod * inv2 % mod;
    NTT(b, len, -1);
    for(int i = n; i < len; i++)
        b[i] = 0;
}

int n;

signed main()
{
    scanf("%lld", &n);
    for(int i = 0; i < n; i++)
        scanf("%lld", &F[i]);
    polysqrt(F, G, n);
    for(int i = 0; i < n; i++)
        printf("%lld ", G[i]);
    return 0;
}
~~~



## 多项式幂函数

**多项式幂函数**是用来解决
$$
G(x) \equiv (F(x)) ^ k \mod x ^ n
$$
先求一遍$\ln$然后乘以$k$再使用$\exp$，就好啦。

**需保证**$F_0 = 1$。

## 多项式的一些普通情况

###  多项式求ln

不保证$F_0 = 1$。不存在，有定理： 

> 在模意义下当且仅当$F_0 = 1$， $F(x)$有对数多项式问题。

### 多项式求exp

不保证$F_0 = 0$ 。同多项式求$\ln$。

### 多项式开根

不保证$F_0 = 1$，但保证$F_0$是$\bmod 998244353$下的二次剩余。

边界求一遍二次剩余即可。

### 多项式幂函数

不保证$F_0 = 1$。可以先找到系数不为$0$的一项，然后让式子除以这一项最后再乘回来就好了
$$
F(x)^k = \bigg(  \frac{F(x)}{x ^ t} \bigg) ^ k x ^ {tk}
$$

## 分治FFT/NTT

给定序列$g$和$f$， 其中
$$
f_i= \sum_{j = 1} ^ i f _{i - 1} g _ j
$$
求$f$， 这里给出一个多项式求逆的方法，（找时间再补分治FFT / NTT）

设$F(x) = \sum_{i = 0} ^ {\infty} f_i x ^ i , G(x) = \sum_{i = 0} ^ {\infty}g_i x ^ i$，且$g_0 = 0$，

所以有
$$
F(x) G(x) = \sum_{i = 0} ^ {\infty} \sum_{j + k = i}f_jg_k = F(x) - f_0 x ^ 0 \\
F(x)G(x) \equiv F(x) - f_0 \mod x ^ n \\
F(x) \equiv (1  - G(x)) ^ {-1} \mod x ^ n
$$

## 下降幂多项式乘法

假设我们已知$n$次多项式$f(x)$在$[0, n]$的点值， 求它的下降幂表示，

设$f(x) = \sum_{i = 0} ^ n b_i x^{\underline{i}} = \sum_{i = 0} ^ n b_i\frac{x!}{(x -i)!}$，则有
$$
\frac{f(x)}{x!}  = \sum_{i = 0} ^ n b_i \frac{1}{(x - i) !} = b \ast e^x
$$
 

先转化为点值最后卷上$e^x$即可。

~~~c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int mod = 998244353;
const int g = 3;
const int gi = 332748118;
const int N = 8e5 + 10;

int recover[N];

int n, m;

int A[N], B[N], F[N], G[N], H[N];

int qpow(int a, int b)
{
    int t = 1;
    while(b != 0)
    {
        if(b & 1)t = t * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return t;
}

int inv(int x)
{
    return qpow(x, mod - 2);
}

void NTT(int *a, int len, int type)
{
    for(int i = 0; i < len; i++)
        if(i < recover[i])swap(a[i], a[recover[i]]);
    for(int k = 1; k < len; k <<= 1)
    {
        int x = qpow(type == 1 ? g : gi, (mod - 1) / (k << 1));
        for(int i = 0; i < len; i += (k << 1))
        {
            int w = 1;
            for(int j = 0; j < k; j++)
            {
                int y = a[i + j] % mod;
                int z = w * a[i + j + k] % mod;
                a[i + j] = (y + z) % mod;
                a[i + j + k] = ((y - z) % mod + mod) % mod;
                w = w * x % mod;
            }
        }
    }
    if(type == -1)
    {
        int iv = inv(len);
        for(int i = 0; i < len; i++)
            a[i] = a[i] * iv % mod;
    }
}

int fac[N], ifac[N];

signed main()
{
    scanf("%lld%lld", &n, &m);
    for(int i = 0; i <= n; i++)
        scanf("%lld", &F[i]);
    for(int i = 0; i <= m; i++)
        scanf("%lld", &G[i]);
    int len = 1, cnt = 0, Len = max(n, m) << 1;
    while(len <= (Len << 1))len <<= 1, cnt++;
    for(int i = 0; i < len; i++)
        recover[i] = (recover[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
    fac[0] = ifac[0] = 1;
    for(int i = 1; i <= Len; i++)
        fac[i] = fac[i - 1] * i % mod;
    for(int i = 1; i <= Len; i++)
        ifac[i] = inv(fac[i]);
    for(int i = 0; i <= Len; i++)
    {
        if(i & 1)B[i] = ((mod - ifac[i]) % mod + mod) % mod;
        else B[i] = ifac[i]; A[i] = ifac[i];
    }
    NTT(A, len, 1); NTT(B, len, 1);
    NTT(F, len, 1); NTT(G, len, 1);
    for(int i = 0; i < len; i++)
    {
        F[i] = A[i] * F[i] % mod;
        G[i] = A[i] * G[i] % mod;
    }
    NTT(F, len, -1); NTT(G, len, -1);
    for(int i = 0; i <= Len; i++)
        H[i] = F[i] % mod * G[i] % mod * fac[i] % mod;
    NTT(H, len, 1);
    for(int i = 0; i < len; i++)
        H[i] = H[i] * B[i] % mod;
    NTT(H, len, -1);
    for(int i = 0; i <= n + m; i++)
        printf("%lld ", H[i]);
    return 0;
}
~~~

## 多项式除法

